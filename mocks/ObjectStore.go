package mocks

import "github.com/osiloke/gostore"
import "github.com/stretchr/testify/mock"

// ObjectStore is an autogenerated mock type for the ObjectStore type
type ObjectStore struct {
	mock.Mock
}

// All provides a mock function with given fields: count, skip, store
func (_m *ObjectStore) All(count int, skip int, store string) (gostore.ObjectRows, error) {
	ret := _m.Called(count, skip, store)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(int, int, string) gostore.ObjectRows); ok {
		r0 = rf(count, skip, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int, string) error); ok {
		r1 = rf(count, skip, store)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllCursor provides a mock function with given fields: store
func (_m *ObjectStore) AllCursor(store string) (gostore.ObjectRows, error) {
	ret := _m.Called(store)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(string) gostore.ObjectRows); ok {
		r0 = rf(store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(store)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllWithinRange provides a mock function with given fields: filter, count, skip, store, opts
func (_m *ObjectStore) AllWithinRange(filter map[string]interface{}, count int, skip int, store string, opts gostore.ObjectStoreOptions) (gostore.ObjectRows, error) {
	ret := _m.Called(filter, count, skip, store, opts)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) gostore.ObjectRows); ok {
		r0 = rf(filter, count, skip, store, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(filter, count, skip, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchFilterDelete provides a mock function with given fields: filter, store, opts
func (_m *ObjectStore) BatchFilterDelete(filter []map[string]interface{}, store string, opts gostore.ObjectStoreOptions) error {
	ret := _m.Called(filter, store, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}, string, gostore.ObjectStoreOptions) error); ok {
		r0 = rf(filter, store, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Before provides a mock function with given fields: id, count, skip, store
func (_m *ObjectStore) Before(id string, count int, skip int, store string) (gostore.ObjectRows, error) {
	ret := _m.Called(id, count, skip, store)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(string, int, int, string) gostore.ObjectRows); ok {
		r0 = rf(id, count, skip, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, string) error); ok {
		r1 = rf(id, count, skip, store)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *ObjectStore) Close() {
	_m.Called()
}

// CreateDatabase provides a mock function with given fields:
func (_m *ObjectStore) CreateDatabase() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTable provides a mock function with given fields: table, sample
func (_m *ObjectStore) CreateTable(table string, sample interface{}) error {
	ret := _m.Called(table, sample)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(table, sample)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: key, store
func (_m *ObjectStore) Delete(key string, store string) error {
	ret := _m.Called(key, store)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(key, store)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilterBefore provides a mock function with given fields: id, filter, count, skip, store, opts
func (_m *ObjectStore) FilterBefore(id string, filter map[string]interface{}, count int, skip int, store string, opts gostore.ObjectStoreOptions) (gostore.ObjectRows, error) {
	ret := _m.Called(id, filter, count, skip, store, opts)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) gostore.ObjectRows); ok {
		r0 = rf(id, filter, count, skip, store, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(id, filter, count, skip, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterBeforeCount provides a mock function with given fields: id, filter, count, skip, store, opts
func (_m *ObjectStore) FilterBeforeCount(id string, filter map[string]interface{}, count int, skip int, store string, opts gostore.ObjectStoreOptions) (int64, error) {
	ret := _m.Called(id, filter, count, skip, store, opts)

	var r0 int64
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) int64); ok {
		r0 = rf(id, filter, count, skip, store, opts)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(id, filter, count, skip, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterCount provides a mock function with given fields: filter, store, opts
func (_m *ObjectStore) FilterCount(filter map[string]interface{}, store string, opts gostore.ObjectStoreOptions) (int64, error) {
	ret := _m.Called(filter, store, opts)

	var r0 int64
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, gostore.ObjectStoreOptions) int64); ok {
		r0 = rf(filter, store, opts)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(filter, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDelete provides a mock function with given fields: filter, store, opts
func (_m *ObjectStore) FilterDelete(filter map[string]interface{}, store string, opts gostore.ObjectStoreOptions) error {
	ret := _m.Called(filter, store, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, gostore.ObjectStoreOptions) error); ok {
		r0 = rf(filter, store, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilterGet provides a mock function with given fields: filter, store, dst, opts
func (_m *ObjectStore) FilterGet(filter map[string]interface{}, store string, dst interface{}, opts gostore.ObjectStoreOptions) error {
	ret := _m.Called(filter, store, dst, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string, interface{}, gostore.ObjectStoreOptions) error); ok {
		r0 = rf(filter, store, dst, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilterGetAll provides a mock function with given fields: filter, count, skip, store, opts
func (_m *ObjectStore) FilterGetAll(filter map[string]interface{}, count int, skip int, store string, opts gostore.ObjectStoreOptions) (gostore.ObjectRows, error) {
	ret := _m.Called(filter, count, skip, store, opts)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) gostore.ObjectRows); ok {
		r0 = rf(filter, count, skip, store, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(filter, count, skip, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterReplace provides a mock function with given fields: filter, src, store, opts
func (_m *ObjectStore) FilterReplace(filter map[string]interface{}, src interface{}, store string, opts gostore.ObjectStoreOptions) error {
	ret := _m.Called(filter, src, store, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, interface{}, string, gostore.ObjectStoreOptions) error); ok {
		r0 = rf(filter, src, store, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FilterSince provides a mock function with given fields: id, filter, count, skip, store, opts
func (_m *ObjectStore) FilterSince(id string, filter map[string]interface{}, count int, skip int, store string, opts gostore.ObjectStoreOptions) (gostore.ObjectRows, error) {
	ret := _m.Called(id, filter, count, skip, store, opts)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) gostore.ObjectRows); ok {
		r0 = rf(id, filter, count, skip, store, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, int, int, string, gostore.ObjectStoreOptions) error); ok {
		r1 = rf(id, filter, count, skip, store, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUpdate provides a mock function with given fields: filter, src, store, opts
func (_m *ObjectStore) FilterUpdate(filter map[string]interface{}, src interface{}, store string, opts gostore.ObjectStoreOptions) error {
	ret := _m.Called(filter, src, store, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, interface{}, string, gostore.ObjectStoreOptions) error); ok {
		r0 = rf(filter, src, store, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: key, store, dst
func (_m *ObjectStore) Get(key string, store string, dst interface{}) error {
	ret := _m.Called(key, store, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}) error); ok {
		r0 = rf(key, store, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetByField provides a mock function with given fields: name, val, store, dst
func (_m *ObjectStore) GetByField(name string, val string, store string, dst interface{}) error {
	ret := _m.Called(name, val, store, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, interface{}) error); ok {
		r0 = rf(name, val, store, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetByFieldsByField provides a mock function with given fields: name, val, store, fields, dst
func (_m *ObjectStore) GetByFieldsByField(name string, val string, store string, fields []string, dst interface{}) error {
	ret := _m.Called(name, val, store, fields, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []string, interface{}) error); ok {
		r0 = rf(name, val, store, fields, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetStore provides a mock function with given fields:
func (_m *ObjectStore) GetStore() interface{} {
	ret := _m.Called()

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Replace provides a mock function with given fields: key, store, src
func (_m *ObjectStore) Replace(key string, store string, src interface{}) error {
	ret := _m.Called(key, store, src)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}) error); ok {
		r0 = rf(key, store, src)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Save provides a mock function with given fields: store, src
func (_m *ObjectStore) Save(store string, src interface{}) (string, error) {
	ret := _m.Called(store, src)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, interface{}) string); ok {
		r0 = rf(store, src)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, interface{}) error); ok {
		r1 = rf(store, src)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveAll provides a mock function with given fields: store, src
func (_m *ObjectStore) SaveAll(store string, src ...interface{}) ([]string, error) {
	ret := _m.Called(store, src)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, ...interface{}) []string); ok {
		r0 = rf(store, src...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(store, src...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Since provides a mock function with given fields: id, count, skip, store
func (_m *ObjectStore) Since(id string, count int, skip int, store string) (gostore.ObjectRows, error) {
	ret := _m.Called(id, count, skip, store)

	var r0 gostore.ObjectRows
	if rf, ok := ret.Get(0).(func(string, int, int, string) gostore.ObjectRows); ok {
		r0 = rf(id, count, skip, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gostore.ObjectRows)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, string) error); ok {
		r1 = rf(id, count, skip, store)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stats provides a mock function with given fields: store
func (_m *ObjectStore) Stats(store string) (map[string]interface{}, error) {
	ret := _m.Called(store)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string) map[string]interface{}); ok {
		r0 = rf(store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(store)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: key, store, src
func (_m *ObjectStore) Update(key string, store string, src interface{}) error {
	ret := _m.Called(key, store, src)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}) error); ok {
		r0 = rf(key, store, src)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
